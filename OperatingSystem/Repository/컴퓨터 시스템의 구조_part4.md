# 🏢 컴퓨터 시스템의 구조_part4

---

## 👩🏻‍🏫 복습

---

- CPU는 PC라는 레지스터를 통해, 다음 기계어를 실행시키는데, 이때 **인터럽트가 발생되면 PC는 메모리 영역의 운영체제 영역을 실행시킴**

![1.png](..%2FImage%2F%EC%BB%B4%ED%93%A8%ED%84%B0%20%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98%20%EA%B5%AC%EC%A1%B0_part4%2F1.png)


## 🔎 I/O 디바이스 컨트롤러

---

![2.png](..%2FImage%2F%EC%BB%B4%ED%93%A8%ED%84%B0%20%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98%20%EA%B5%AC%EC%A1%B0_part4%2F2.png)


**1. 타이머가 인터럽트를 걸음**

-> CPU의 제어권이 운영체제로 넘어가서, 다른 프로그램을 실행하도록 CPU 작업을 재분배함

![3.png](..%2FImage%2F%EC%BB%B4%ED%93%A8%ED%84%B0%20%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98%20%EA%B5%AC%EC%A1%B0_part4%2F3.png)


**2. 기계어를 실행하다가, 파일을 읽어올 때 I/O 장치에게 "특권 명령"임으로 운영체제에게 부탁을 함**
- CPU는 디스크에 직접 접근이 불가능하므로, Disk Device Controller에게 **"특권 명령"임에 운영체제에게 부탁을 함**

-> CPU는 사용자 프로그램의 기계어를 실행하다가, 운영체제의 기계어로 점프(움직임)이 필요함

-> 인터럽트를 통해 해당 움직임을 명령함

**시스템 콜**
- 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것

1. 실행중인 프로그램에서 인터럽트 라인을 세팅함
2. CPU가 다음 기계어를 실행하기 전에 운영체제의 기계어를 읽음

-> 하드웨어가 아닌 소프트웨어가 I/O 작업을 위해 인터럽트를 호출하는 것 

- 해당 작업이 호출된 후, 운영체제는 메모리 상에 있는 다른 작업을 먼저 처리하라고 CPU에게 명령을 함
- 만약 디스크에서 파일을 가져오는 과정이 끝나면 인터럽트를 발생시킴
- CPU는 현재 작업을 모두 멈춘 후, 다음 번의 인터럽트로 들어온 내용(파일로 불러와서 읽는 프로그램 작업)을 처리함

![4.png](..%2FImage%2F%EC%BB%B4%ED%93%A8%ED%84%B0%20%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98%20%EA%B5%AC%EC%A1%B0_part4%2F4.png)

![5.png](..%2FImage%2F%EC%BB%B4%ED%93%A8%ED%84%B0%20%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98%20%EA%B5%AC%EC%A1%B0_part4%2F5.png)


- 디바이스 컨트롤러 = **해당 I/O 장치 유형을 관리하는 일종의 작은 CPU**
- 제어 정보를 위해 Control Register, Status Register를 가짐
- Local Buffer를 가짐(일종의 Data Register)
- I/O는 실제 Device와 Local Buffer 사이에서 일어남
- Device Controller는 I/O작업이 끝났을 경우, Interrupt로 CPU에 그 사실을 알림
-> 해당 작업이 끝나면, 컴퓨터의 CPU에 인터럽트를 걸어, 해당 작업이 다음번에 실행되도록 함


- Device Driver(장치 구동기)
  - OS 코드 중 각 장치별 처리 루틴 -> **SoftWare**
  - 운영체제 안에 있는 코드에서, I/O 컨트롤러에게 해당 작업을 넘기는 코드임
  - **CPU 내부에서 처리함**


- Device Controller(장치 제어기)
  - 각 장치를 통제하는 일종의 작은 CPU -> **HardWare**
  - **CPU 내부에서 처리되지 않음**


## 🔎 인터럽트의 정의 및 종류

---

인터럽트
- 인터럽트 당한 시점의 레지스터와 Program Counter를 Save한 후, CPU의 제어를 인터럽트 처리 루틴에 넘김

인터럽트(넓은 의미)
1. 소프트웨어 인터럽트(Trap)
- 소프트웨어가 인터럽트를 발생시킴
  - Exception: 프로그램이 오류를 범한 경우
  - System Call: 프로그램이 커널 함수를 호출하는 경우

2. 하드웨어 인터럽트(Interrupt)
- 타이머, 디스크 컨트롤러가 발생시키는 일반적인 경우
- 하드웨어가 인터럽트를 발생시킴


## 👨🏻‍🏫 인터럽트 관련 용어

---

인터럽트 백터
- 해당 인터럽트의 처리 루틴 주소를 가지고 있음

-> 인터럽트의 종류별로 인터럽트 발생 시, 어떤 실행을 해야 하는지 담고 있는 포인터, 장소


인터럽트 처리 루틴(InterRupt Service Routine, 인터럽트 핸들러)
- 해당 인터럽트를 처리하는 커널 함수

-> 인터럽트 백터에 따라 움직여, 어떤 일을 해야 하는지 정의되어 있는 코드


## ❔ 운영체제에게 CPU의 주도권이 넘어가는 경우는 언제 언제가 있나요?(3가지)

---

- 인터럽트 라인을 세팅할 때는 2가지 방법이 있음

인터럽트 라인 세팅

1. 하드웨어 장치가 인터럽트를 걸어서 CPU의 주도권이 운영체제에게 넘어가는 경우

2. 프로그램 소프트웨어가 인터럽트 라인을 세팅하여 CPU의 주도권이 운영체제에게 넘어가는 경우 = 시스템 콜

-> 소프트웨어 인터럽트, 트랩이라고 불림

3. 예외가 발생되는 경우
- 0으로 나누는 연산의 경우, 권한이 없는 기계어를 실행하는 순간


## ❔ 사용자 프로그램이 CPU 주도권이 있다가, 주도권이 운영체제에게 넘어가는 경우는 언제가 있나요?(2가지)

---

1. CPU를 계속 사용할 경우, 타이머에 의해 인터럽트가 발생될 때

2. I/O 작업이 있어, 다음 작업에게 CPU 주도권을 넘겨줘야 할때


## 👨🏻‍🏫 결론

---

- 현대의 운영체제는 인터럽트에 의해 구동됨
-> 운영체제는 인터럽트가 들어올 때만 일을 한다.


## 🎯 동기식 입출력과 비동기식 입출력

---

- CPU = I/O 작업 요청자

동기식 I/O = I/O 작업과 CPU에서 작동중인 작업이 동일할 때

비동기식 I/O = I/O 작업과 CPU에서 작동중인 작업이 불일치할 때


**동기식 입출력(SynChronous I/O)**

- I/O 요청 후, 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어감


구현 방법1

- I/O가 끝날 때까지 CPU를 낭비시킴
- 매시점 하나의 I/O만 일어날 수 있음

**-> I/O 장치도 리소스 낭비** 
**-> 시스템 안에도 I/O도 1개만 실행됨**


구현 방법2

- I/O가 완료될 때까지 해당 프로그램에게서 CPU 주도권을 빼앗음
- I/O 처리를 기다리는 줄에 해당 프로그램을 줄 세움
- 다른 프로그램에게 CPU의 주도권을 줌

**-> 다른 I/O 장치를 실행시킬 수도 있음**


**비동기식 입출력(AsynChronous I/O)**
- I/O가 시작된 후, 입출력 작업이 끝나기를 기다리지 않고, 제어가 사용자 프로그램에 즉시 넘어감
- I/O 요청을 받기 전, 해당 작업을 처리하기 전에 다른 프로그램을 처리할 수 있음
- 단순히, 파일을 읽어오는 것이 아닌 파일에다가 어떤 내용을 쓰라는 요청이라면, 해당 내용을 끝나고 단순히 결과만 받으면 될 경우


**I/O 종류의 구분(2종류)**
- 읽기(Read)
- 쓰기(Write)

-> 다만, 해당 작업에서 꼭 쓰기가 끝난 후, 작업을 처리하겠다면 동기식으로도 처리할 수 있음


**-> 동기, 비동기의 두 가지의 경우, 모두 I/O의 완료는 인터럽트로 알려줌**


## 🔎 자세히 살펴보기

---

**동기식 입출력(SynChronous I/O작업)**

1. 시스템 콜 발생
2. I/O 작업 수행
3. I/O 작업 수행후, Dive Controller가 인터럽트를 발생시킴
4. CPU가 다음 작업에 해당 내용을 처리함


**비동기식 입출력(ASynChronous I/O작업)**

1. 시스템 콜 방생
2. I/O 작업 수행
3. CPU는 해당 작업과 상관 없이 다음 작업일을 수행함


![6.png](..%2FImage%2F%EC%BB%B4%ED%93%A8%ED%84%B0%20%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98%20%EA%B5%AC%EC%A1%B0_part4%2F6.png)


![7.png](..%2FImage%2F%EC%BB%B4%ED%93%A8%ED%84%B0%20%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98%20%EA%B5%AC%EC%A1%B0_part4%2F7.png)


## 🎯 DMA(Direct Memory Access)

---

### ❔ 인터럽트가 자주 걸리게 된다면?
- CPU는 작업 내용을 멈추고, 해당 내용을 처리하고 다시 작업을 처리하는데 해당 내용이 작업이 끝나지 않는 기아 상태가 됨

-> 계속 인터럽트가 걸리기 때문임

-> CPU도 굉장히 비효율적이게 됨


**DMA Controller**

- 메모리를 접근할 수 있는 장치는 CPU밖에 없으므로, I/O Controller가 작업을 끝내더라도 해당 내용을 메모리에 올리지 못함

→ 작업이 끝나면 로컬 버퍼가 있에 저장하고, CPU가 각 I/O 장치의 로컬 버퍼의 내용을 가져가서 작업 내용을 처리함

→ 만약 인터럽트가 빈번하다면 굉장히 비효율적이게 됨

→ 때문에 직접 메모리에 접근할 수 있는 컨트롤러가 존재함

- 인터럽트가 자주 걸리는 것을 막기 위해서 존재함

### 🔎  인터럽트가 자주 걸리는 상황

1. I/O 장치의 작업 내용이 모두 끝나 로컬 버퍼에 작업 내용 존재함(해당 I/O의 여러 작업 내용)
2. DMA Controller가 직접 메모리 공간에 해당 내용을 모두 카피함
3. 인터럽트를 발생시켜서 해당 I/O 작업이 끝났다고 알려서, 해당 내용을 처리할 수 있도록 함

![8.png](..%2FImage%2F%EC%BB%B4%ED%93%A8%ED%84%B0%20%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98%20%EA%B5%AC%EC%A1%B0_part4%2F8.png)


**DMA(Direct Memory Access)**

- 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용함
- CPU의 중재 없이 Device Controller가 Device의 Buffer Storage의 내용에 메모리에 Block 단위로 직접 전송함
- 바이트 단위가 아닌 Block 단위로 인터럽트를 발생시킴
- 첫번째 그림의 Controller = 디스크 컨트롤러 → CPU에게 인터럽트를 발생시킴
- 두번째 그림의 Controller = DMA Controntroller
  - 인터럽트 없이, 해당 I/O 작업의 내용을 메인 메모리(Primary Memroy)에 올려두는 것을 의미함
  - 해당 작업이 끝나면 CPU에게 인터럽트를 걸어서 해당 내역을 처리할 수 있게함

![9.png](..%2FImage%2F%EC%BB%B4%ED%93%A8%ED%84%B0%20%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98%20%EA%B5%AC%EC%A1%B0_part4%2F9.png)


## 🔎 서로 다른 입출력 기계어 (2가지)

---

- CPU에서 실행하는 명령어 = 기계어

**→ I/O를 수행하는 기계어는 2가지 종류가 있음**

1. I/O를 수행하는 Special Instruction에 의해 **(I/O를 전담하는 기계어를 두는 방법)**
- 왼쪽 그림

2. Memory Mapped I/O에 의해 (메모리에 I/O관련 기계어를 두는 방법)
- 오른쪽 그림
- 메모리 주소를 I/O 장치에 두는 것이 아닌, 메인 메모리에 연장해서 두고, 실제 I/O를 메모리 접근하는 방법으로 처리하는 방법

![10.png](..%2FImage%2F%EC%BB%B4%ED%93%A8%ED%84%B0%20%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98%20%EA%B5%AC%EC%A1%B0_part4%2F10.png)


## 🔎 저장장치 계층 구조

---

- 해당 계층 구조에서 아래쪽에서는 데이터의 원본이 저장되며, 필요할 때 해당 내용을 불러옴
- **캐싱: 자주 읽는 데이터를 임시로 저장시켜 읽는 속도를 향상시키는 방법**

**→ 재사용이 많은 것을 주로 올려둠**

- Primary = 메인 메모리 = CPU가 직접 실행 가능함
  - 휘발성 메모리

- Secondary = I/O 장치에 의해서 실행이 가능함
  - 비휘발성 메모리

![11.png](..%2FImage%2F%EC%BB%B4%ED%93%A8%ED%84%B0%20%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98%20%EA%B5%AC%EC%A1%B0_part4%2F11.png)

<br/>

## 📖 Reference

---

[KOCW 반효경 교수님 - 운영제체](http://www.kocw.net/home/cview.do?cid=4b9cd4c7178db077)

[운영체제와 정보기술의 원리 - 반효경 교수님](https://www.aladin.co.kr/shop/wproduct.aspx?ISBN=K762639583&start=pnaver_02)