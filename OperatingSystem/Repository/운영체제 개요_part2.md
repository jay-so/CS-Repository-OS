# 🏢 운영체제 개요 - Part2

---

## 📞 CPU 스케줄링이란?

---

**CPU 스케줄링**
- 여러 프로그램들이 CPU를 사용하겠다고, CPU 큐에서 대기중인데 어떤 프로그램에게 CPU 권한을 줄것인가를 결정하는 스케줄링

예시
- 프로세스 3개가 CPU를 사용하겠다고 CPU 큐에 대기중임
- 도착 순서: P1, P2, P3
- CPU 사용 시간: P1 > P2 = P3
-> 24초를 다쓰면 I/O 대기열 큐에서 대기하도록 함

<br/>

1. FCFS(First-Come First-Served)
- 먼저 도착한 프로그램이 먼저 CPU를 사용하게 하는 스케줄링
- P1 프로세스 -> P2 프로세스 -> P3 vmfhtptm
- 대기 시간 = P3의 경우, 27초
- 평균 대기 시간 = (0 + 24 + 27) /3 = 17초

![1.png](..%2FImage%2F%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%20%EA%B0%9C%EC%9A%94_part2%2F1.png)


### ❔ 만약 P2가 먼저 도착한다면?
- CPU 사용 시간이 적은 P2가 먼저 도착한다면, 대기 시간이 짧아짐
- 대기 시간 = P1의 경우 6초, P3의 경우 3초
- 평균 대기 시간 (6 + 0 + 3) /3 = 3초

![2.png](..%2FImage%2F%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%20%EA%B0%9C%EC%9A%94_part2%2F2.png)


### 단점
- CPU를 사용하는 프로그램에 따라 대기시간 및 평균 대기 시간의 범위가 달라짐
- **공평한 것 같지만, 효율적이지는 않음**

<br/>

2. SJF(Shortest-Job-First)
- FCFS의 단점을 개선하기 위해 등장함
- CPU 큐에 있는 작업 중에서 금번 CPU 사용 시간이 가장 짧은 프로세스를 제일 먼저 스케줄링 앞에 둠
- SJF는 **최소 평균 대기 시간(minium average waiting time)을 보장함**
- P3가 가장 소요 시간이 짧음 -> P3 작업 먼저 수행 -> P2 작업 수행 -> P1 작업 수행

![3.png](..%2FImage%2F%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%20%EA%B0%9C%EC%9A%94_part2%2F3.png)


### 👩🏻‍🏫 단점

- **Starvation(기아 현상)이 발생 가능함**

**→ 특정 프로그램이 무한정 대기 상태일 수도 있음**


### ❔ 왜 무한 대기 상태에 있을 수도 있는가?
- 프로그램들이 I/O 큐에 있는 작업을 끝내고 CPU 큐에 대기함으로써, 긴 CPU 소요 시간을 차지하는 프로그램은 영원히 CPU 작업을 수행하지 못하고, 무한 대기 상태에 있을 수도 있음
- **효율성에는 좋지만 형평성에 문제가 발생함**

3. RR(Round Robin)
- 현재 CPU 스케줄링에서 가장 많이 사용됨
- 각 프로세스는 동일 크기의 CPU 할당시간을 가짐(각 프로그램의 CPU 소요 시간과 관계없이 동일하게 CPU 할당 시간을 가지도록 함)
- ** 할당 시간이 끝나면 인터럽트가 발생하여 프로세스는 CPU를 빼앗기고, CPU 큐의 제일 뒤에 줄을 섬**
- N개의 프로세스가 CPU 큐에 있는 경우

**⇒ 어떤 프로세스도 (n-1) * 할당 시간 이상 기다리지 않음**

**⇒ 대기시간도 프로세스의 CPU 사용 시간에 비례함**

![4.png](..%2FImage%2F%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%20%EA%B0%9C%EC%9A%94_part2%2F4.png)

## 장점
- CPU 소요 시간이 짧은 프로그램은 해당 스케줄링 후에 I/O 작업을 처리하러 I/O 대기열 큐에 대기하도록 이동하면 됨
- CPU 소요 시간이 짧은 프로그램 

-> CPU 큐에 위치한 시간도 짧아짐


- CPU 소요 시간이 긴 프로그램

-> CPU 큐에 위치한 시간도 길어짐

-> CPU 소요 시간에 따라 대기 시간이 비례함

- **운영체제가 자원을 관리할때, 가장 효율적이며 형평적인 방법임**

<br/>

## 🛄 메모리 관리

---

- 디스크에는 실행 파일이 존재함
- 메모리에는 운영체제가 실행중임

-> 디스크에 있는 실행 파일 A와 실행 파일 B를 실행하면 해당 파일들이 메모리에 올라가 프로세스가 됨

![5.png](..%2FImage%2F%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%20%EA%B0%9C%EC%9A%94_part2%2F5.png)


### 🔎 자세히 살펴보기
- 사실 해당 부분에서는 한 단계가 숨겨져 잇음

**→ 가상 메모리 단계**

- **프로그램을 실행하면, 메모리에 올라가는 독자적인 메모리 주소가 생성됨(가상 메모리)**

**→ 바로 메모리에 올라가는 것이 아닌, 독자적인 메모리 공간을 형성함**


- **실제 메모리에는 가상 메모리 공간에서 당장 프로그램 실행에 필요한 부분만 올려둠**
- 또한 **가상 메모리의 공간이 넓기 때문에, 통째로 물리적인 메모리에 두면 사용도 되지 않는 메모리 공간이 낭비됨**

**→ 때문에 필요한 부분만 쪼개서 실제 메모리 공간에 올려둠**


### ❔ 만약 메모리에 공간이 모두 차 있다면?
- 해당 메모리 안에 공간이 모두 차 있다면, 사용중인 메모리에서 공간을 확보해야 함

→ 이를 위해 사용중인 **메모리 영역에서 우선순위가 낮다고 판단되는 메모리 공간은 디스크의 스왑 영역에 옮겨짐**


### ❔ 둘 다 디스크 영역인데 뭐가 다른가?

- 둘 다 디스크 영역이지만, 실행파일이 있는 공간은 파일 시스템으로써, 디스크에 해당 내용을 저장하여 컴퓨터의 전원이 나가더라도 내용들이 저장되어야 할 필요가 있는 내용들임
- **실제 메모리 공간에서 쫒겨난 가상 메모리 공간을 스왑 영역이라고 함**

**→ 스왑 영역은 메모리의 연장선이라고 볼 수도 있음, 만약 컴퓨터의 전원이 나가면 디스크의 스왑 영역안에 있는 내용들은 의미가 없는 내용이기가 되기에 자동으로 지워져야 하는 공간임**

- **실제 메모리 (휘발성)**
- **디스크(파일 시스템, 스왑 영역) - 비휘발성**

![6.png](..%2FImage%2F%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%20%EA%B0%9C%EC%9A%94_part2%2F6.png)


### ❔ 만약 실제 메모리가 가득 찼다면, 어떤 내용이 스왑영역으로 옮겨질까?
- **각각의 프로세스 내용을 “페이지”라고함**

**→ 실제 메모리에 있는 어떤 “페이지”의 내용을 스왑 영역으로 옮겨질까?**

**예시**

- **CPU가 요청한 페이지 순서**
- 1,1,1,1,2,2,3,3,2,4,5,**(현재 시각)** ……
- 운영체제 → (요청) 디스크 컨트롤러 요청하여 1번 페이지를 사용함

![7.png](..%2FImage%2F%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%20%EA%B0%9C%EC%9A%94_part2%2F7.png)


### 🔎 작동 과정
1. 운영체제 → (요청) 디스크 컨트롤러 요청하여 1번 페이지를 사용함
- **그 이후, 1번 페이지 요청 시 메모리 상에 있는 1번 페이지를 그대로 가져와 사용함**

![8.png](..%2FImage%2F%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%20%EA%B0%9C%EC%9A%94_part2%2F8.png)


2. **2번 요청 시, 실제 메모리에는 해당 내용이 없기 때문에 메모리에 올려둠**
- **그 이후, 2번 페이지 요청 시 메모리 상에 있는 2번 페이지를 그대로 가져와 사용함**

![9.png](..%2FImage%2F%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%20%EA%B0%9C%EC%9A%94_part2%2F9.png)


3. 1. 3번 요청시, 해당 내용도 실제 메모리에 없기 때문에 메모리에 올려둠
- **2번 페이지 요청과 동일하게 3번도 메모리 상 위에 있는 3번 페이지를 사용함**

![10.png](..%2FImage%2F%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%20%EA%B0%9C%EC%9A%94_part2%2F10.png)


4. 4번 요청도 동일함

![11.png](..%2FImage%2F%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%20%EA%B0%9C%EC%9A%94_part2%2F11.png)


5. **5번 페이지 요청 시, 실제 메모리 상위에는 모두 꽉차 하나의 페이지를 스왑 영역으로 이동시켜야 함**
   → 운영체제는 어떤 페이지를 스왑 영역으로 이동시키는게 효율적인지 판단하게 됨


### Q. 현재 시각 5번 페이지를 보관하기 위해 어떤 페이지를 삭제해야 하는가?


**방법1. LRU**

- **가장 오래 전에 참조한 페이지를 삭제하는 방법**
- **5번 페이지를 넣기 위해서는 가장 오래전에 참조한 페이지인 1번 페이지를 스왑 영역을 이동 시킴**

**→ 오래전에 사용한 1번 페이지는 다시 사용할 가능성이 적다고 판단함**


![12.png](..%2FImage%2F%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%20%EA%B0%9C%EC%9A%94_part2%2F12.png)


### 👩🏻‍🏫 단점

- **사용횟수가 많더라도 시간이 많이 지나면 과연 자주 사용하지 않는지에 대한 단점이 존재함**


**방법2. LFU**

- **참조 횟수가 가장 적은 페이지를 삭제하는 방법**
- **사용 횟수가 적은 페이지 4번을 스왑 영역으로 이동 시킴**

**→ 과거에 많이 사용한 페이지는 다시 사용할 가능성이 높다고 판단함**

![13.png](..%2FImage%2F%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%20%EA%B0%9C%EC%9A%94_part2%2F13.png)


### 👩🏻‍🏫 단점

- **과거에 자주 사용한 페이지가 현재에도 자주 사용하는지에 대한 단점이 존재함**


### 👨🏻‍🏫 결론

- 두 가지 “페이지” 관리에 대한 연구는 현재에도 계속 진행중임

**→ 어떤 작업이 미래에 있을 지 모르므로 어떤 과정이 효율적이고 형평적인지 고민을 계속 진행되고 있음**

<br/>

## 🤖 디스크 스케줄링

---

- 파일에 대한 저장, 수정 요청 시 해당 과정은 디스크 큐에 쌓이게 됨(시간 순서순으로 쌓임)
- 디스크는 원판이 회전 중임
- 디스크의 헤드가 이동중임으로 1번을 읽을때는 1번쪽으로 디스크 헤드가 이동하며, 100번 트랙을 읽을 때에는 디스크 헤드가 100번쪽으로 이동함
- **디스크 헤드 이동 시간 = 디스크의 읽고 쓰기 작업 중에 가장 많이 걸리는 시간**
- **디스크를 효율적으로 관리하는 방법 = 디스크의 헤더가 움직이는 시간이 적게 걸리게 스케줄링함**

![14.png](..%2FImage%2F%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%20%EA%B0%9C%EC%9A%94_part2%2F14.png)


### ❔ 디스크 요청 순서대로 작업을 처리한다면?

- **디스크 헤드가 1번, 100번, 3번, 99번, 2번으로 이동함으로 비효율적임**


### ❔ 디스크 스케줄링이 필요한 이유

**디스크 접근 시간(Access time)의 구성**

1. **탐색 시간(Seek Time)**
    - **디스크 헤더가 움직이는 시간**
    - 헤드를 해당 트랙(실린더)으로 움직이는데 걸리는 시간

2. 회전 시간(Rotational Latency)
    - **탐색 시간 다음으로 오래걸리는 시간**
    - 헤드가 원하는 섹터에 도달하기까지 걸리는 시간

3. 전송 시간(Transfer time)
    - 실제 데이터의 전송 시간

**→ 디스크 스케줄링이 필요함**

디스크 스케줄링(Disk Scheduling)

- seek. time을 최소화하는 것이 목표
- seek time ~ seek distance


![15.png](..%2FImage%2F%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%20%EA%B0%9C%EC%9A%94_part2%2F15.png)


### 🔎 디스크 스케줄링

1. **FCFS(First-Come First-Served)**
- 먼저 디스크 요청에 들어온 순서대로 디스크를 스케줄링함

**→ 헤더의 이동이 너무 김으로 비효율적임**

- **0, 14, 37, 53 … = 디스크 트랙의 번호**


![16.png](..%2FImage%2F%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%20%EA%B0%9C%EC%9A%94_part2%2F16.png)


2. **SSTF(Shortest Seek Time First)**
- **FCFS가 너무 비효율적임으로 디스크 스케줄링은 해당 방법이 등장함**
- **현재 디스크 헤더 위치에서 제일 짧은 디스크 헤더 이동을 가지는 순서대로 디스크를 스케줄링함**
- 현재 위치 = 53번

→ 현재위치에서 가장 가까운 65번을 먼저 처리함

**→ 65번 위치를 기준으로 가장 가까운 67번을 먼저 처리함**

![17.png](..%2FImage%2F%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%20%EA%B0%9C%EC%9A%94_part2%2F17.png)


3. **SCAN(SCAN 알고리즘)**
- **현재 가장 많이 사용되고 있는 디스크 스케줄링 방법**
- 헤드가 디스크의 한쪽 끝에서 다른쪽 끝으로 이동하며, 가는 길목에 있는 모든 요청을 처리함
- 다른 한쪽 끝에 도달하면 역방향으로 이동하며 오는 길목에 있는 모든 요청을 처리하며, 다시 반대쪽 끝으로 이동함
- **디스크 큐에 어떤 작업들이 대기하고 있는지 관심이 없고, 디스크 헤더는 한쪽 끝에서 다른쪽 끝으로 이동하면서 가는 동안 해당 작업 요청이 오게 되면 처리함**
- **헤더의 이동거리가 짧아지므로 효율적이고, 가는 길목에 작업이 있다면 처리함으로 형평성 문제도 해결함**

<br/>

## 🔎 저장 장치 계층구조와 캐싱(Caching)

---

- **메인 메모리 = D램**
- **CPU안에는 레지스터라는 메모리가 있음**
- **CPU의 레지스터와 메인 메모리의 속도 차를 개선하기 위해 캐시 메모리 공간이 존재함**
- **디스크(Magnetic Disk) = 보조 기억 장치**
- 위로 올라갈 수록 빠르며, 가격이 비싸다.
- **Volatiltye(휘발성) - Secondary에 있는 부분은 비휘발성**
- **위에는 휘발성임**
- **메모리 계층에서 Primary는 메인 계층을 의미하며CPU가 직접 처리할 수 있음을 의미함, Secondary 계층은 I/O 장치이며 CPU가 직접 처리할 수 없음을 의미함**

![18.png](..%2FImage%2F%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%20%EA%B0%9C%EC%9A%94_part2%2F18.png)

- 최종적인 데이터가 쌓여 있는 공간 = 제일 아래쪽
- 필요한 데이터가 있을 경우 = 올려서 사용함
- 저장이 필요가 있을 때 = 내려서 저장함

→ 캐싱: 동일한 해당 데이터가 필요할때, 저장 장치까지 갈 필요 없이 중간에 저장하는 캐싱 영역에다가 복사시켜 읽기 속도를 빠르게 하기 위해서

→ 용량에 한계가 있기 때문에, 해당 캐싱 내역에 필요 없는 부분을 내쫓을지 결정함

→ 캐싱 알고리즘

![19.png](..%2FImage%2F%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%20%EA%B0%9C%EC%9A%94_part2%2F19.png)

<br/>

## 🔎 플래시 메모리

---

- 플래시 메모리
    - 반도체 장치**(하드 디스크는  마그네틱 장치임)**
    - NAND형(스토리지), NOR형(임베디드 코드저장용)

- 플래시 메모리의 특징
    - NonVolatile**(비 휘발성)**
    - Low Power Consumption**(전력 소모가 적음)**
    - Shock Resistance**(물리적인 충격에 강함)**
    - Small Size**(크기가 작음)**
    - LightWeight**(가벼움)**

  **단점**

    - 쓰기 횟수 제약이 있음
    - 데이터 손실 가능성이 있음

**→ 하드웨어의 약점을 소프트웨어로 개선하는 방식으로 발전됨**

- 플래시 메모리의 사용 형태
    - 휴대폰, PDA 등 임베디드 시스템 구성용
    - USB용 메모리 스틱
    - 디지털 카메라 등의 SD 카드, CompactFlash, Smart Media Card
    - 모바일 장치뿐 아닌 대용량 시스템에서 SSD(Solid State Drive)란 이름으로 하드 디스크 대체 시도


![20.png](..%2FImage%2F%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%20%EA%B0%9C%EC%9A%94_part2%2F20.png)

<br/>

## 🔎 운영체제의 종류

---

- 서버용, PC용, 스마트 디바이스용 운영체제
    - 스마트폰용: 안드로이드, IOS, Linux
    - 서버용: Linux
    - PC용: MacOs, 윈도우, Linux

→ Linux는 모든 운영체제 안에서 사용됨

- 공개 소프트웨어(Open Source Software)
    - Linux, Android

→ 공개 소프트웨어 vs 비공개 소프트웨어로 나누어짐

![21.png](..%2FImage%2F%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%20%EA%B0%9C%EC%9A%94_part2%2F21.png)

<br/>

## 📖 Reference

---

[KOCW 반효경 교수님 - 운영제체](http://www.kocw.net/home/cview.do?cid=4b9cd4c7178db077)

[운영체제와 정보기술의 원리 - 반효경 교수님](https://www.aladin.co.kr/shop/wproduct.aspx?ISBN=K762639583&start=pnaver_02)
